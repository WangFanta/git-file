须知：只有TCP有粘包现象，UDP永远不会粘包
发送数据时间间隔很短，数据了很小，会合到一起，产生粘包
range返回一个列表，xrange是生成一个生成器对象，python已经取消xrange
yml - 是列表

垃圾回收机制   还有一个__del__方法，会在计数为0的时候进行调用
Python中的垃圾回收是以引用计数为主，分代收集为辅。引用计数的缺陷是循环引用的问题。
在Python中，如果一个对象的引用数为0，Python虚拟机就会回收这个对象的内存。
对象的别名被赋予新的对象会-1
循环引用，会导致无法回收他们，造成内存泄漏
引入gc模块，gc.collect()会回收，0代表只检查第一代的对象，
1代表检查一，二代的对象，2代表检查一，二，三代的对象，如果不传参数，执行一个full collection，也就是等于传2。
触发垃圾回收：调用gc.collect()/当达到阈值的时候也会被回收，阈值可以通过gc.get_count()来查看/程序退出的时候

产生死锁的条件：
资源独占排他使用/不可剥夺的条件（在未使用完毕之前不会被剥夺）/在申请新资源的时候同时占用原来的资源/等待（p2等p1的资源，p3等p2的资源）


new方法 会执行
class Dog(object):
    __instance = None
    __init_flag = False

    def __new__(cls, name):
        if cls.__instance == None:
            cls.__instance = object.__new__(cls)
            return cls.__instance
        else:
            #返回上一次创建的对象的引用
            return cls.__instance

深浅拷贝和赋值
a=2
b=a
print id(a),id(b) #46751984 46751984
a=3
print b,id(a) #2 46751960

c=[1]
d=c
print id(d),id(c) #49133256 49133256
c.append(2)
print d#[1, 2]

import copy
e=[3,4,["aaa","bbb"]]
f=copy.copy(e)
g=copy.deepcopy(e)
print id(e),id(f) # 49134152 49150984
e.append(5)
e[2].append("ccc")
print f#[3, 4, ['aaa', 'bbb', 'ccc']]
print g#[3, 4, ['aaa', 'bbb']]

sbuprocess模块
import subprocess
a=subprocess.check_output("ls")
b=subprocess.call("ifconfig")   #正确执行返回0，没有正确执行就报错
print a
print b

在外面输入参数
import argparse
parser = argparse.ArgumentParser()
parser.add_argument('integer', type=int, help='display an integer')
args = parser.parse_args()
print(args.integer)

parser = argparse.ArgumentParser()
parser.add_argument("--square", help="display a square of a given number", type=int)
parser.add_argument("--cubic", help="display a cubic of a given number", type=int)
args = parser.parse_args()

if args.square:
    print(args.square ** 2)
if args.cubic:     #可以既输入square又输入cubic
    print(args.cubic ** 3)


json是可以在不同语言之间交换数据的，而pickle只在python之间使用。
json只能序列化最基本的数据类型，而pickle可以序列化所有的数据类型，包括类，函数都可以序列化。
