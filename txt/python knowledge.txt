须知：只有TCP有粘包现象，UDP永远不会粘包
发送数据时间间隔很短，数据了很小，会合到一起，产生粘包

new方法 会执行
class Dog(object):
    __instance = None
    __init_flag = False

    def __new__(cls, name):
        if cls.__instance == None:
            cls.__instance = object.__new__(cls)
            return cls.__instance
        else:
            #返回上一次创建的对象的引用
            return cls.__instance

深浅拷贝和赋值
a=2
b=a
print id(a),id(b) #46751984 46751984
a=3
print b,id(a) #2 46751960

c=[1]
d=c
print id(d),id(c) #49133256 49133256
c.append(2)
print d#[1, 2]

import copy
e=[3,4,["aaa","bbb"]]
f=copy.copy(e)
g=copy.deepcopy(e)
print id(e),id(f) # 49134152 49150984
e.append(5)
e[2].append("ccc")
print f#[3, 4, ['aaa', 'bbb', 'ccc']]
print g#[3, 4, ['aaa', 'bbb']]

sbuprocess模块
import subprocess
a=subprocess.check_output("ls")
b=subprocess.call("ifconfig")   #正确执行返回0，没有正确执行就报错
print a
print b

在外面输入参数
import argparse
parser = argparse.ArgumentParser()
parser.add_argument('integer', type=int, help='display an integer')
args = parser.parse_args()
print(args.integer)

parser = argparse.ArgumentParser()
parser.add_argument("--square", help="display a square of a given number", type=int)
parser.add_argument("--cubic", help="display a cubic of a given number", type=int)
args = parser.parse_args()

if args.square:
    print(args.square ** 2)
if args.cubic:     #可以既输入square又输入cubic
    print(args.cubic ** 3)


json是可以在不同语言之间交换数据的，而pickle只在python之间使用。
json只能序列化最基本的数据类型，而pickle可以序列化所有的数据类型，包括类，函数都可以序列化。
